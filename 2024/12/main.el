;;; -*- lexical-binding: t; -*-
(require 'f) (require 'ht)
(defconst adv/inp (f-read-text "input.txt"))
(defconst adv/coords (ht-create))
(defconst adv/regions nil)
(defconst adv/grid (-map #'s-trim (-filter #'s-present? (s-lines adv/inp))))
(defconst adv/h (length adv/grid))
(defconst adv/w (-max (-map #'length adv/grid)))
(defconst adv/all (-mapcat (lambda (y) (-map (lambda (x) (cons x y)) (-iota adv/w))) (-iota adv/h)))
(defun adv/at (c)
  (when-let* ((x (car c)) (y (cdr c)) ((and (>= x 0) (< x adv/w) (>= y 0) (< y adv/h))))
    (seq-elt (seq-elt adv/grid y) x)))
(defun adv/n (c)
  (let ((x (car c)) (y (cdr c)))
    `((,(- x 1) . ,y) (,(+ x 1) . ,y) (,x . ,(- y 1)) (,x . ,(+ y 1)))))
(defun adv/containing (c)
  (when-let* ((v (adv/at c))
              (q (adv/n c))
              (r (list c))
              ((not (ht-contains? adv/coords c))))
    (ht-set! adv/coords c t)
    (while q
      (let ((d (pop q)))
        (when (equal (adv/at d) v)
          (unless (ht-contains? adv/coords d)
            (push d r)
            (ht-set! adv/coords d t)
            (setq q (-concat (adv/n d) q))))))
    (cons (format "%c" v) r)))
(defconst adv/regions (-non-nil (-map #'adv/containing adv/all)))
(defun adv/area (r) (length (cdr r)))
(defun adv/perimeter (r)
  (let ((cs (cdr r)))
    (-sum (--map (- 4 (length (-filter (lambda (n) (-contains? cs n)) (adv/n it)))) cs))))
(defconst adv/p1 (-sum (--map (* (adv/area it) (adv/perimeter it)) adv/regions)))
(defun adv/edges (cs c)
  (let ((nl (-zip-pair (adv/n c) '(w e n s))))
    (-map #'cdr (-filter (lambda (n) (not (-contains? cs (car n)))) nl))))
(defun adv/extcorn (e)
  (*
   (length (--filter (-contains? '(n s) it) (cdr e)))
   (length (--filter (-contains? '(e w) it) (cdr e)))))
(defun adv/intcorn (all edges c)
  (let* ((x (car c)) (y (cdr c))
         (cn (cons x (- y 1))) (cs (cons x (+ y 1))) (cw (cons (- x 1) y)) (ce (cons (+ x 1) y))
         (tn (when-let* ((e (ht-get edges cn))) (-contains? e 's)))
         (ts (when-let* ((e (ht-get edges cs))) (-contains? e 'n)))
         (te (when-let* ((e (ht-get edges cw))) (-contains? e 'e)))
         (tw (when-let* ((e (ht-get edges ce))) (-contains? e 'w))))
    (length
     (-non-nil
      (list
       (and tn te (-contains? all (cons (- x 1) (- y 1))))
       (and ts te (-contains? all (cons (- x 1) (+ y 1))))
       (and tn tw (-contains? all (cons (+ x 1) (- y 1))))
       (and ts tw (-contains? all (cons (+ x 1) (+ y 1)))))))))
(defun adv/possible-intcorn (cs)
  (let* ((minx (-min (-map #'car cs))) (maxx (+ 1 (-max (-map #'car cs))))
         (miny (-min (-map #'cdr cs))) (maxy (+ 1 (-max (-map #'cdr cs))))
         (all (-mapcat (lambda (y) (-map (lambda (x) (cons x y)) (-iota maxx minx))) (-iota maxy miny)))
         )
    (--filter (not (-contains? cs it)) all)))
(defun adv/sides (r)
  (let* ((cs (cdr r))
         (es (-filter #'cdr (--map (cons it (adv/edges cs it)) cs)))
         (edges (ht-from-alist es))
         (extcorn (-sum (-map #'adv/extcorn es)))
         (intcorn (-sum (-non-nil (--map (adv/intcorn cs edges it) (adv/possible-intcorn cs))))))
    ;; (list extcorn intcorn)))
    (+ extcorn intcorn)))
(defconst adv/p2 (-sum (--map (* (adv/area it) (adv/sides it)) adv/regions)))
